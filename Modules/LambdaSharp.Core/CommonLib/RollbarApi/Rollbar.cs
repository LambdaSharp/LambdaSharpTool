/*
 * LambdaSharp (Î»#)
 * Copyright (C) 2018-2019
 * lambdasharp.net
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by https://quicktype.io
//
// To change quicktype's target language, run command:
//
//   "Set quicktype target language"

using System;
using System.Collections.Generic;

using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace LambdaSharp.Core.RollbarApi
{

    public partial class Rollbar
    {
        [JsonProperty("access_token")]
        public string AccessToken { get; set; }

        [JsonProperty("data")]
        public Data Data { get; set; }
    }

    public partial class Data
    {
        [JsonProperty("environment")]
        public string Environment { get; set; }

        [JsonProperty("body")]
        public DataBody Body { get; set; }

        [JsonProperty("level")]
        public string Level { get; set; }

        [JsonProperty("timestamp")]
        public long Timestamp { get; set; }

        [JsonProperty("code_version")]
        public string CodeVersion { get; set; }

        [JsonProperty("platform")]
        public string Platform { get; set; }

        [JsonProperty("language")]
        public string Language { get; set; }

        [JsonProperty("framework")]
        public string Framework { get; set; }

        [JsonProperty("custom")]
        public object Custom { get; set; }

        [JsonProperty("fingerprint")]
        public string Fingerprint { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }
    }

    public partial class DataBody
    {
        [JsonProperty("trace_chain")]
        public Trace[] TraceChain { get; set; }

        [JsonProperty("message")]
        public Message Message { get; set; }
    }

    public partial class Message
    {
        [JsonProperty("body")]
        public string Body { get; set; }
    }

    public partial class Trace
    {
        [JsonProperty("frames")]
        public Frame[] Frames { get; set; }

        [JsonProperty("exception")]
        public ExceptionClass Exception { get; set; }
    }

    public partial class ExceptionClass
    {
        [JsonProperty("class")]
        public string Class { get; set; }

        [JsonProperty("message")]
        public string Message { get; set; }

        [JsonProperty("description")]
        public string Description { get; set; }
    }

    public partial class Frame
    {
        [JsonProperty("filename")]
        public string Filename { get; set; }

        [JsonProperty("lineno")]
        public int? Lineno { get; set; }

        [JsonProperty("method")]
        public string Method { get; set; }
    }

    public partial struct FrameArg
    {
        public long? Integer;
        public string String;

        public static implicit operator FrameArg(long Integer) => new FrameArg { Integer = Integer };
        public static implicit operator FrameArg(string String) => new FrameArg { String = String };
    }

    public partial struct LocalsArg
    {
        public bool? Bool;
        public string String;

        public static implicit operator LocalsArg(bool Bool) => new LocalsArg { Bool = Bool };
        public static implicit operator LocalsArg(string String) => new LocalsArg { String = String };
    }

    public partial class Rollbar
    {
        public static Rollbar FromJson(string json) => JsonConvert.DeserializeObject<Rollbar>(json, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters = {
                FrameArgConverter.Singleton,
                LocalsArgConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class FrameArgConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FrameArg) || t == typeof(FrameArg?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new FrameArg { Integer = integerValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new FrameArg { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type FrameArg");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FrameArg)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type FrameArg");
        }

        public static readonly FrameArgConverter Singleton = new FrameArgConverter();
    }

    internal class LocalsArgConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LocalsArg) || t == typeof(LocalsArg?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new LocalsArg { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new LocalsArg { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type LocalsArg");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LocalsArg)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type LocalsArg");
        }

        public static readonly LocalsArgConverter Singleton = new LocalsArgConverter();
    }
}
